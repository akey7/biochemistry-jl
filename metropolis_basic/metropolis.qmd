---
title: "Metropolis Algorithm"
format:
  html:
    toc: true
    html-math-method: mathjax
    code-fold: false
---

```{julia}
#| label: using-things
#| eval: true
#| include: false

using Printf
using Plots
using Random
using Distributions

plotlyjs()
Random.seed!(1234)
```

## Define p(x) and f(x)

Assuming

$$ p(x) = {f(x) \over NC} $$

Where NC is a normalizing constant that is unknown. Therefore, this demo will use the f(x) PDF as a proxy for an unknown p(x).

### Define the function

```{julia}
#| label: f-pdf
#| eval: true
#| include: true

function f(xs)
    μ1 = 1
    σ1 = 1
    dist1 = Normal(μ1, σ1)

    μ2 = -2.0
    σ2 = 0.5
    dist2 = Normal(μ2, σ2)

    μ3 = -5.0
    σ3 = 1.5
    dist3 = Normal(μ3, σ3)

    pdf.(dist1, xs) + pdf.(dist2, xs).*0.25 + pdf.(dist3, xs)
end;  # ; suppresses output in the Quarto document.
```

### Set domain of f(x) for subsequent code 

```{julia}
#| label: f-domain
#| eval: true
#| include: true

domain_min = -11
domain_max = 5
```

### Plot f(x)

```{julia}
#| label: plot-f-pdf
#| eval: true
#| include: true

xs = range(start=domain_min, stop=domain_max, length=200)
ys = f(xs)
plot(xs, ys)
```

## Sample f(x)

### Draw samples with Metropolis algorithm

```{julia}
#| label: metropolis
#| eval: true
#| include: true

num_steps = 100
σ_step = 1.0

samples = zeros(Float64, num_steps)
samples[1] = f(rand(Uniform(domain_min, domain_max)))

for i ∈ 2:num_steps
    next_proposal = f(rand(Normal(samples[i-1], σ_step)))
    if min(1, f(next_proposal) / f(samples[i-1])) > rand()
        samples[i] = next_proposal
    else
        samples[i] = samples[i-1]
    end
end

print(samples)
```
